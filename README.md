# ООП

------------


#### - Почти всегда оперируем объектами в программе и это удобнее делать через классы
#### - Класс - это шаблон, blueprint по которому в дальнейшем могут формироваться объекты 
#### - в этом шаблоне могут быть как перемены, данные (атрибуты класса) так и функиции(методы) 

### пример класса 
    class Cat:
		def __init__(self, color, age, name):
			self.color = color
			self.age = age
			self.name = name
		def draw():
			print(f"{self.name} is f{self.color} and is f{self.age} old.")

#### Создание объекта
		pet = Cat("Red", "7", "Fluffy")
		pet.bark()  

## Базовые принципы ООП
1. ## Инкапсуляция
	- класс вообще должен восприниматься как единая, целостная конструкция, все внутренние манипуляции с его данными должны быть сокрыты в этом классе и в идеале недоступны извне
	- чтобы пользователь класса не мог случайно или намеренно вмешаться в его внутреннюю работу, данные и методы можно скрывать. То есть, к скрытым данным и методам нельзя напрямую обращаться извне, только внутри класса. Такой механизм в ООП называется инкапсуляцией. Благодаря инкапсуляции класс становится единым целым, а работа с ним возможна только через разрешенные (публичные) свойства и методы.
2. ## Наследование
	- Наследование позволяет как бы вынести «за скобки» общее для разных классов.
	- пример с разработкой графического редактора, в котором можно рисовать графические примитивы: линии, прямоугольники, эллипсы и другие фигуры.Но, очевидно, в этих классах будут общие свойства: coords, width и color. Получаем дублирование кода, то есть, нарушение принципа DRY – не повторяйся. Именно эти общие свойства целесообразно вынести в общий для всех них базовый класс Figure, чтобы данные и методы класса Figure появлялись в дочерних классах Line, Rect и Ellipse, необходимо унаследовать их от класса Figure. То есть, благодаря механизму наследования классов, мы можем использовать ранее созданные классы и расширять их функциональность.
3. ## Полиморфизм
	- Благодаря наследованию и полиморфизму мы можем на уровне ООП описывать общую, абстрактную архитектуру работы программы в целом, а потом, создавая дочерние классы, наполнять эту программу конкретным содержимым, конкретным поведением.
	- снова вернусь к примеру с графическим редактором, где у нас было три класса с одним базовым Figure. В базовый класс я также добавил метод draw() и вы сейчас поймете почему. Допустим, что для каждого класса были созданы объекты. И наша задача их нарисовать в окне программы. Для этого есть метод draw(), который существует в каждом дочернем классе: Line, Rect и Ellipse. Так вот, если бы не было полиморфизма, то мы в программе должны были бы сначала перебрать список из объектов Line, затем, список из объектов Rect и наконец, из объектов Ellipse. Очевидно, это не лучший подход. Представьте, что в будущем у нас будут появляться все новые и новые виды графический примитивов, например, треугольник, пятиугольник, трапеция и т.п. Тогда списков разных типов объектов будет все больше и больше, а программа все сложнее и сложнее. Да и, кроме того, появится дублирование кода.Но, благодаря параметрическому полиморфизму, мы можем оперировать разными типами объектов через их единый базовый класс, в нашем случае Figure. Достаточно создать список, каждый элемент которого будет иметь тип Figure и через ссылку на базовый класс вызывать функцию draw(). Причем автоматически будет вызван метод draw() соответствующего дочернего класса. 
######(нужно доучить полифорфизм) 



## Классы и атрибуты
-  переменные внутри класса обычно называются атрибутами класса или его свойствами
   ######пример
```python
class Point:
	color = 'red'
	circle = 2
```
- сам класс образует пространство имен, в данном случае с именем Point, в котором находятся две переменные color и circle. И мы можем обращаться к ним, используя синтаксис для пространства имен
``` python 
 Point.color = 'black'```
- А чтобы увидеть все атрибуты класса можно обратиться к специальной коллекции __dict__:
``` Point.__dict__```
Здесь отображается множество служебных встроенных атрибутов и среди них есть два наших: color и circle.

- Теперь сделаем следующий шаг и создадим экземпляры этого класса. В нашем случае для создания объекта класса Point достаточно после его имени прописать круглые скобки:
`a = Point()`
Давайте создадим еще один объект этого класса:
`b = Point()`
Появилась переменная b, которая ссылается на новый объект (он расположен по другому адресу) и в этом объекте мы также видим два атрибута класса Point. По аналогии можно создавать произвольное количество экземпляров класса.

- С помощью функции type мы можем посмотреть тип данных для переменных a или b:
`type(a)`
Эту принадлежность можно проверить, например, так:
`type(a) == Point` или `isinstance(a, Point)`

- Во-первых, объекты a и b образуют свое пространство имен – пространство имен экземпляров класса и, во-вторых, не содержат никаких собственных атрибутов. Свойства color и circle принадлежат непосредственно классу Point и находятся в нем, а объекты a и b лишь имеют ссылки на эти атрибуты класса. Поэтому я не случайно называю их именно атрибутами класса, подчеркивая этот факт. То есть, атрибуты класса – общие для всех его экземпляров. 

- Давайте изменим значение свойства circle на 1: `Point.circle = 1`  
И в обоих объектах это свойство стало равно 1. Мало того, если посмотреть коллекцию __dict__ у объектов: `a.__dict__`
то она будет пустой, так как в наших экземплярах отсутствуют какие-либо атрибуты. Но, тем не менее, мы можем через них обращаться к атрибутам класса:`a.color
b.circle` 
Но, если мы выполним присваивание, например:  `a.color = 'green'`
в объекте a свойство color стало 'green', а в b – прежнее. Почему? Дело в том, что мы здесь через переменную a обращаемся к пространству имен уже экземпляра класса и оператор присваивания в Python создает новую переменную, если она отсутствует в текущей локальной области видимости, то есть, создается атрибут color уже непосредственно в объекте a.

#### Добавление и удаление атрибутов класса

- мы можем создавать новые атрибуты и в классе, например, так:
`Point.type_pt = 'disc'`  или 
`setattr(Point, 'prop', 1)` Если эту функцию применить к уже существующему атрибуту: `setattr(Point, 'type_pt', 'square')` то оно будет изменено на новое значение.

- Если же мы хотим прочитать какое-либо значение атрибута, то достаточно обратиться к нему. `Point.circle` но, при обращении к несуществующему атрибуту класса, например: `Point.a` возникнет ошибка. Этого можно избежать, если воспользоваться специальной встроенной функцией: `getattr(Point, 'a', False)`, Здесь третий аргумент – возвращаемое значение, если атрибут не будет найден. Эту же функцию можно вызвать и с двумя аргументами.
- мы можем удалять любые атрибуты из класса. Сделать это можно, по крайней мере, двумя способами. Первый – это воспользоваться оператором del `del Point.prop`
Если повторить эту команду и попытаться удалить несуществующий атрибут, возникнет ошибка. Поэтому перед удалением рекомендуется проверять существование удаляемого свойства. Делается это с помощью функции hasattr: `hasattr(Point, 'prop')` Она возвращает True, если атрибут найден и False – в противном случае.
Также удалить атрибут можно с помощью функции:`delattr(Point, 'type_pt')`

